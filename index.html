<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<style>
body {
	background: black;
	margin: 0px;
}
</style>
<script>
"use strict";

let the_game = undefined;

const TICK_INTERVAL = 50;
const LEMMING_BBOX_W = 9;
const LEMMING_BBOX_H = 23;
const SPLAT_DISTANCE = 250;
const WALK_PERIOD = 14;
const FALL_PERIOD = 4;
const SPLAT_TIME = 11;
const DIG_PERIOD = 14;
const DIG_ADVANCE = [0,1,0,1,0,0,0,0,1,0,1,0,0,0];
const MINE_ADVANCE_X = [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0];
const MINE_ADVANCE_Y = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0];
const MINE_BOX_X = [5,6,7,10,14,17,20,20,19,19,20,20,17,14,10,7,6];
const MINE_BOX_Y = [8,7,8, 9, 9,11,14,19,20,20,18,14,11, 9, 9,8,7];
const MINE_PERIOD = 17;
const BASH_ADVANCE = [0,0,0,0,1,1,0,0,0,0,0,0,0];
const BASH_PERIOD = 13;
const BRICK_COLOR = 0xff5ecfff;
const BUILD_PERIOD = 19;
const BUILD_TICK = 9;
const BUILD_ADVANCE_X = [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0];
const BUILD_ADVANCE_Y = [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0];
const SHRUG_TIME = 10;
const SHRUG_TICK = 15;

class Lemming {
	constructor(x, y) {
		this.x = x;
		this.y = y;
		this.direction = 1;
		this.mode = 'walk';
		this.state = 'alive';
		this.fall_distance = 0;
		this.frame = 0;
		this.bricks = 0;
	}

	static new_faller(x, y) {
		return new Lemming(x, y);
	}

	get_sprite_name() {
		if (this.mode === 'splat') {
			return `splat${this.frame}`;
		} else if (this.mode === 'shrug') {
			return `shrug${this.frame}`;
		} else if (this.fall_distance > 0) {
			return `fall${this.frame % FALL_PERIOD}`;
		} else if (this.mode === 'builder') {
			return `build${this.frame % BUILD_PERIOD}`;
		} else if (this.mode === 'basher') {
			return `bash${this.frame % BASH_PERIOD}`;
		} else if (this.mode === 'miner') {
			return `mine${this.frame % MINE_PERIOD}`;
		} else if (this.mode === 'digger') {
			return `dig${this.frame % DIG_PERIOD}`;
		} else {
			return `walk${this.frame % WALK_PERIOD}`;
		}
	}

	bounding_box() {
		const x = this.x - Math.floor(LEMMING_BBOX_W / 2);
		const y = this.y - LEMMING_BBOX_H;
		const w = LEMMING_BBOX_W;
		const h = LEMMING_BBOX_H;
		return {x, y, w, h};
	}

	contains_mouse(x, y) {
		const bbox = this.bounding_box();
		return x >= bbox.x - 16 && x < bbox.x + bbox.w + 16 && y >= bbox.y - 16 && y < bbox.y + bbox.h + 16;
	}

	tick(terrain, exit) {
		const bbox = this.bounding_box();
		const d = this.direction;

		// Consider dying
		if (this.mode === 'splat') {
			this.frame += 1;
			if (this.frame >= SPLAT_TIME) {
				this.state = 'dead';
			}
			return;
		}

		// Consider whether it's fallen off the edge
		if (this.x < 0 || this.x >= terrain.image_data.width || this.y < 0 || this.y - bbox.h >= terrain.image_data.height) {
			this.state = 'dead';
			return;
		}

		// Consider falling
		let fell = 0;
		for (let offset = 1; offset <= 4; offset++) {
			if (terrain.rect_is_empty(bbox.x, bbox.y + bbox.h + offset - 1, bbox.w, 2)) {
				// Lemming can fall at least this amount
				fell = offset;
			} else {
				break;
			}
		}
		if (fell !== 0) {
			this.y += fell;
			if (this.fall_distance === 0) {
				this.frame = 0;
			}
			this.fall_distance += fell;
			this.frame += 1;
			if (fell === 4) {
				return;
			}
		}

		if (this.fall_distance >= SPLAT_DISTANCE) {
			this.mode = 'splat';
			this.frame = 0;
			return;
		}
		if (this.fall_distance > 0) {
			this.frame = 0;
			this.mode = 'walk';
		}
		this.fall_distance = 0;

		// Consider exit
		if (exit.contains(this.x, this.y)) {
			this.state = 'finished';
			return;
		}

		// Consider post-build shrug
		if (this.mode === 'shrug') {
			this.frame += 1;
			if (this.frame >= SHRUG_TIME) {
				this.frame = 0;
				this.mode = 'walk';
			}
			return;
		}

		// Consider actions
		if (this.mode === 'builder') {
			const f = this.frame % BUILD_PERIOD;
			this.frame += 1;
			if (this.bricks <= 0 && f === SHRUG_TICK) {
				this.mode = 'shrug';
				this.frame = 0;
				return;
			}
			if (this.direction > 0) {
				this.x += BUILD_ADVANCE_X[f];
				if (f === BUILD_TICK) {
					terrain.fill(this.x + 3, this.y, 10, 1, BRICK_COLOR);
					this.bricks -= 1;
				}
			} else {
				this.x -= BUILD_ADVANCE_X[f];
				if (f === BUILD_TICK) {
					terrain.fill(this.x - 13, this.y, 10, 1, BRICK_COLOR);
					this.bricks -= 1;
				}
			}
			this.y -= BUILD_ADVANCE_Y[f];
			return;
		}
		if (this.mode === 'basher') {
			this.frame += 1;
			if (this.direction > 0) {
				terrain.erase(bbox.x + bbox.w - 3, bbox.y, 3, bbox.h);
				this.x += BASH_ADVANCE[this.frame % BASH_PERIOD];
			} else {
				terrain.erase(bbox.x - 1, bbox.y, 3, bbox.h);
				this.x -= BASH_ADVANCE[this.frame % BASH_PERIOD];
			}
			return;
		}
		if (this.mode === 'digger') {
			const adv = DIG_ADVANCE[this.frame % DIG_PERIOD];
			terrain.erase(bbox.x - 3, bbox.y + bbox.h - 3, bbox.w + 6, 3 + adv);
			this.y += adv;
			this.frame += 1;
			return;
		}
		if (this.mode === 'miner') {
			const f = this.frame % MINE_PERIOD;
			if (this.direction > 0) {
				terrain.erase(this.x + MINE_BOX_X[f] - 13 - 1, this.y + MINE_BOX_Y[f] - 36, 7, 17);
				this.x += MINE_ADVANCE_X[f];
			} else {
				terrain.erase(this.x - MINE_BOX_X[f] + 13 - 7, this.y + MINE_BOX_Y[f] - 36, 7, 17);
				this.x -= MINE_ADVANCE_X[f];
			}
			this.y += MINE_ADVANCE_Y[f];
			this.frame += 1;
			return;
		}

		// Try scrambling downhill first, if that doesn't work try walking straight and then scrambling uphill
		if (this.mode === 'walk') {
			for (let offset = 2; offset >= -2; offset--) {
				if (terrain.rect_is_empty(bbox.x + d, bbox.y + offset, bbox.w, bbox.h)) {
					this.x += d;
					this.y += offset;
					this.frame += 1;
					return;
				}
			}

			// No choice but to reverse direction
			this.direction = -this.direction;
			return;
		}
	}
}

async function load_image_data(filename, scale) {
	const img = new Image();
	img.src = filename;
	await img.decode();

	const canvas = document.createElement('canvas');
	canvas.width = img.width * scale;
	canvas.height = img.height * scale;
	const ctx = canvas.getContext('2d');
	ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);

	return ctx.getImageData(0, 0, canvas.width, canvas.height);
}

async function load_image_element(filename) {
	const img = new Image();
	img.src = filename;
	await img.decode();
	return img;
}

class Terrain {
	constructor(image_data, scale) {
		this.image_data = image_data;
		this.scale = scale;
		this.dirty = [];
	}

	static async load(filename, scale) {
		const image_data = await load_image_data(filename, scale);
		return new Terrain(image_data, scale);
	}

	rect_is_empty(x, y, w, h) {
		x *= this.scale;
		y *= this.scale;
		w *= this.scale;
		h *= this.scale;
		const background = 0xff000000;
		const data_view = new DataView(this.image_data.data.buffer);
		const thisw = this.image_data.width;
		const thish = this.image_data.height;
		for (let y1 = y; y1 < y + h; y1++) {
			for (let x1 = x; x1 < x + w; x1++) {
				if (x1 >= 0 && x1 < thisw && y1 >= 0 && y1 < thish) {
					let byte_offset = 4 * (y1 * thisw + x1);
					if (data_view.getUint32(byte_offset, true) !== background) {
						return false;
					}
				}
			}
		}
		return true;
	}

	erase(x, y, w, h) {
		this.fill(x, y, w, h, 0xff000000);
	}

	fill(x, y, w, h, color) {
		x *= this.scale;
		y *= this.scale;
		w *= this.scale;
		h *= this.scale;
		const data_view = new DataView(this.image_data.data.buffer);
		const thisw = this.image_data.width;
		const thish = this.image_data.height;
		for (let y1 = y; y1 < y + h; y1++) {
			for (let x1 = x; x1 < x + w; x1++) {
				if (x1 >= 0 && x1 < thisw && y1 >= 0 && y1 < thish) {
					let byte_offset = 4 * (y1 * thisw + x1);
					data_view.setUint32(byte_offset, color, true);
				}
			}
		}
		this.dirty.push({x, y, w, h});
	}

	take_dirty() {
		const result = this.dirty;
		this.dirty = [];
		return result;
	}
}

class Entrance {
	constructor(x, y, count, ticks) {
		this.x = x;
		this.y = y;
		this.remaining_count = count;
		this.ticks = ticks;
		this.remaining_ticks = 0;
	}

	tick() {
		const result = [];
		if (this.remaining_count > 0 && this.remaining_ticks === 0) {
			result.push(Lemming.new_faller(this.x, this.y));
			this.remaining_ticks = this.ticks;
			this.remaining_count -= 1;
		}
		if (this.remaining_ticks > 0) {
			this.remaining_ticks -= 1;
		}
		return result;
	}
}

class Button {
	constructor(x, y, w, h, action) {
		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;
		this.action = action;
		this.selected = false;
	}

	draw(ctx) {
		ctx.fillStyle = this.selected ? '#fff' : '#800';
		ctx.fillRect(this.x, this.y, this.w, this.h);
		ctx.fillStyle = this.selected ? '#800' : '#fff';
		ctx.fillText(this.action, this.x, this.y + 20);
	}

	contains(x, y) {
		return x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h;
	}
}

class Exit {
	constructor(x, y, w, h) {
		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;
	}

	contains(x, y) {
		return x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h;
	}
}

class Game {
	constructor(canvas, terrain, sprites, entrance, exit, scale) {
		this.canvas = canvas;
		this.terrain = terrain;
		this.drawn_regions = [];
		this.sprites = sprites;
		this.entrance = entrance;
		this.exit = exit;
		this.lemmings = [];
		this.sel_action = undefined;
		this.scale = scale;
		this.scrollx = 0;
		this.scrolly = 0;

		this.timer = setInterval(() => this.tick(), TICK_INTERVAL);
		this.buttons = [
			new Button(0, 0, 100, 50, 'builder'),
			new Button(100, 0, 100, 50, 'basher'),
			new Button(200, 0, 100, 50, 'miner'),
			new Button(300, 0, 100, 50, 'digger'),
		];
	}

	static async load() {
		const canvas = document.getElementById('canvas');
		const scale = scaling_factor();
		const terrain = await Terrain.load('maps/test_level.png', scale);
		const sprite_names = [];
		for (let i = 0; i < WALK_PERIOD; i++) {
			sprite_names.push(`walk${i}`);
		}
		for (let i = 0; i < FALL_PERIOD; i++) {
			sprite_names.push(`fall${i}`);
		}
		for (let i = 0; i < SPLAT_TIME; i++) {
			sprite_names.push(`splat${i}`);
		}
		for (let i = 0; i < SHRUG_TIME; i++) {
			sprite_names.push(`shrug${i}`);
		}
		for (let i = 0; i < BUILD_PERIOD; i++) {
			sprite_names.push(`build${i}`);
		}
		for (let i = 0; i < BASH_PERIOD; i++) {
			sprite_names.push(`bash${i}`);
		}
		for (let i = 0; i < MINE_PERIOD; i++) {
			sprite_names.push(`mine${i}`);
		}
		for (let i = 0; i < DIG_PERIOD; i++) {
			sprite_names.push(`dig${i}`);
		}
		const sprites = {};

		for (const name of sprite_names) {
			sprites[name] = await load_image_element(`sprites/${name}.png`);
		}

		const entrance = new Entrance(142, 210, 10, 40);
		const exit = new Exit(800, 674, 8, 8);

		return new Game(canvas, terrain, sprites, entrance, exit, scale);
	}

	refresh() {
		this.restore_from_terrain(0, 0, this.canvas.width, this.canvas.height);
		this.draw_lemmings();
		this.draw_borders();
		this.draw_buttons();
	}

	tick() {
		this.erase_drawn_regions();
		const next_lemmings = [];
		for (const lemming of this.lemmings) {
			lemming.tick(this.terrain, this.exit);
			if (lemming.state === 'alive') {
				next_lemmings.push(lemming);
			}
		}
		for (const lemming of this.entrance.tick()) {
			next_lemmings.splice(0, 0, lemming);
		}
		this.lemmings = next_lemmings;
		for (const rect of this.terrain.take_dirty()) {
			this.restore_from_terrain(rect.x, rect.y, rect.w, rect.h);
		}
		this.draw_lemmings();
		this.draw_buttons();
	}

	mousedown(x, y) {
		let sel_button = false;
		for (const button of this.buttons) {
			if (button.contains(x, y)) {
				if (button.selected) {
					this.sel_action = undefined;
				} else {
					this.sel_action = button.action;
				}
				sel_button = true;
			}
		}
		if (sel_button) {
			for (const button of this.buttons) {
				button.selected = (this.sel_action === button.action);
			}
			return;
		}

		x -= this.scrollx;
		y -= this.scrolly;
		x /= this.scale;
		y /= this.scale;

		// Search lemmings in reverse order so the "top" one gets selected in preference
		let sel_lemming = undefined;
		let sel_distance = 0;
		if (this.sel_action !== undefined) {
			for (let i = this.lemmings.length - 1; i >= 0; i--) {
				const lemming = this.lemmings[i];
				const distance = Math.sqrt((lemming.x - x) * (lemming.x - x) + (lemming.y - y) * (lemming.y - y));
				if (lemming.state === 'alive' && lemming.contains_mouse(x, y) && lemming.mode !== this.sel_action) {
					if (sel_lemming === undefined || sel_distance < distance) {
						sel_distance = distance;
						sel_lemming = lemming;
					}
				}
			}
		}

		if (sel_lemming !== undefined && sel_lemming.mode !== this.sel_action) {
			if (this.sel_action === 'builder') {
				sel_lemming.bricks = 12;
			}
			sel_lemming.mode = this.sel_action;
			sel_lemming.frame = 0;
			return;
		}
	}

	mousedrag(dx, dy) {
		this.scrollx += dx;
		this.scrolly += dy;
		this.refresh();
	}

	draw_buttons() {
		const ctx = this.canvas.getContext('2d');
		for (const button of this.buttons) {
			button.draw(ctx);
		}
	}

	erase_drawn_regions() {
		for (let region of this.drawn_regions) {
			this.restore_from_terrain(region.x, region.y, region.w, region.h);
		}
		this.drawn_regions = [];
	}

	draw_borders() {
		const ctx = this.canvas.getContext('2d');
		ctx.fillStyle = '#888';
		const tw = this.terrain.image_data.width;
		const th = this.terrain.image_data.height;
		ctx.fillRect(0, 0, this.canvas.width, this.scrolly);
		ctx.fillRect(0, this.scrolly, this.scrollx, this.canvas.height - this.scrolly);
		ctx.fillRect(tw + this.scrollx, this.scrolly, this.canvas.width - tw - this.scrollx, th);
		ctx.fillRect(0, th + this.scrolly, this.canvas.width, this.canvas.height);
	}

	restore_from_terrain(x, y, w, h) {
		const ctx = this.canvas.getContext('2d');
		ctx.putImageData(this.terrain.image_data, this.scrollx, this.scrolly, x - this.scrollx, y - this.scrolly, w, h);
	}

	draw_lemmings() {
		for (const lemming of this.lemmings) {
			this.draw_sprite_bottom_centre(lemming.get_sprite_name(), lemming.x, lemming.y, lemming.direction);
		}
	}

	draw_sprite_bottom_centre(name, x, y, direction) {
		const image_element = this.sprites[name];
		const scale = this.scale;
		let sw = image_element.width;
		let sh = image_element.height;
		x -= Math.floor(sw / 2);
		y -= sh - 1;
		let w = sw * scale;
		let h = sh * scale;
		x *= scale;
		y *= scale;
		x += this.scrollx;
		y += this.scrolly;
		this.drawn_regions.push({x, y, w, h});
		const cw = this.terrain.image_data.width;
		const ch = this.terrain.image_data.height;
		const ctx = this.canvas.getContext('2d');
		let sx = 0;
		let sy = 0;
		if (x < this.scrollx) {
			sx = (x - this.scrollx) / scale;
			w += x - this.scrollx;
			x = this.scrollx;
		}
		if (y < this.scrolly) {
			sy = (y - this.scrolly) / scale;
			h += y - this.scrolly;
			y = this.scrolly;
		}
		if (x + w > cw) {
			w = cw - x;
		}
		if (y + h > ch) {
			h = ch - y;
		}
		if (direction < 0) {
			ctx.scale(-1, 1);
			ctx.drawImage(image_element, sx, sy, sw, sh, -x, y, -w, h);
			ctx.setTransform(1, 0, 0, 1, 0, 0);
		} else {
			ctx.drawImage(image_element, sx, sy, sw, sh, x, y, w, h);
		}
	}
}

function scaling_factor() {
	return 2;
}

function resize() {
	const canvas = document.getElementById('canvas');
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight - 6;

	if (the_game !== undefined) {
		the_game.refresh();
	}
}

function mousedown(e) {
	if (the_game !== undefined) {
		the_game.mousedown(e.offsetX, e.offsetY);
	}
}

function mousemove(e) {
	if (the_game !== undefined && e.buttons) {
		the_game.mousedrag(e.movementX, e.movementY);
	}
}

let touch_coord_by_id = {};
function touchstart(e) {
	touch_coord_by_id = {};
	for (let i = 0; i < e.targetTouches.length; i++) {
		const touch = e.targetTouches[i];
		touch_coord_by_id[touch.identifier] = {
			x: Math.floor(touch.pageX),
			y: Math.floor(touch.pageY),
		};
	}
}

function touchmove(e) {
	let dx = 0;
	let dy = 0;
	for (let i = 0; i < e.targetTouches.length; i++) {
		const touch = e.targetTouches[i];
		if (touch.identifier in touch_coord_by_id) {
			dx += Math.floor(touch.pageX) - touch_coord_by_id[touch.identifier].x;
			dy += Math.floor(touch.pageY) - touch_coord_by_id[touch.identifier].y;
		}
		touch_coord_by_id[touch.identifier] = {
			x: Math.floor(touch.pageX),
			y: Math.floor(touch.pageY),
		};
	}
	if (the_game !== undefined) {
		the_game.mousedrag(dx, dy);
	}
	
}

async function load() {
	resize();
	window.addEventListener('resize', resize);

	the_game = await Game.load();
	the_game.refresh();
}

window.onload = load;
</script>
</head>
<body>
<canvas id="canvas" width="100" height="100" onmousedown="mousedown(event)" onmousemove="mousemove(event)" ontouchstart="touchstart(event)" ontouchmove="touchmove(event)"></canvas>
</body>
</html>
